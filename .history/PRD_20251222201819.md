## PRD — ASCII Raytracer (Code Art) “Terminal Cinema”

### 1) Overview

Build a **minimal but complete raytracer** that renders a 3D scene as **animated ASCII art** directly in the terminal. The “waw” moment: a **live, rotating reflective sphere** over a **checkerboard floor**, with **soft-ish lighting**, **shadows**, and a **moving light source**, all in crisp ASCII.

**Name:** `TerminalRay`
**Output:** terminal frames (ASCII), optionally export to `.txt` frames or `.gif` (stretch).

---

### 2) Goals

**Primary goals**

* Produce a **beautiful ASCII render** that clearly shows 3D form (shading, perspective).
* Have a **waw demo** running with a single command: `python main.py --demo`.
* Keep the implementation **simple** and educational (small codebase, clear modules).

**Non-goals**

* Photorealism, global illumination, BVH acceleration, complex meshes.
* GPU rendering.

---

### 3) Target Users

* You (builder) + anyone watching the demo (friends, recruiters, Twitter).
* People who like “code art” and want to see something “how is this in a terminal??”.

---

### 4) Waw Demo (Definition)

**Demo Scene: “Chrome Orb”**

* Camera: slightly above the ground, looking forward.
* Objects:

  * Sphere A: **reflective** (mirror-like), rotating (or camera orbit).
  * Sphere B: matte colored (diffuse).
  * Plane: **checkerboard**.
* Lighting:

  * 1 point light moving in a circle.
  * Shadows enabled.
  * Ambient + diffuse + specular (Phong/Blinn).
* Animation: 20–30 FPS target in a normal terminal window (even if it’s 10–15 FPS, it should look smooth enough).
* Resolution: e.g. **120×60** characters (configurable).

**The payoff:** the sphere has a highlight that moves + a reflection of the floor pattern.

---

### 5) User Stories

1. As a user, I run a command and instantly see an animated ASCII 3D scene.
2. As a user, I can change resolution, fps cap, and choose a different ASCII palette.
3. As a user, I can render a still image to a text file.
4. As a developer, I can add a new object/material easily.

---

### 6) Functional Requirements

**Core rendering**

* Ray generation per pixel (character cell)
* Intersection:

  * Sphere
  * Plane
* Shading:

  * Ambient term
  * Diffuse (Lambert)
  * Specular (Blinn-Phong)
* Shadows: cast a shadow ray toward the light
* Reflections: at least **1 bounce** for mirror material (configurable: 0–2)

**ASCII conversion**

* Map computed luminance `0..1` to an ASCII gradient string (e.g. `" .:-=+*#%@"`)
* Optional: “density-correct” mapping (tweak gamma)

**Animation**

* Time loop with:

  * camera orbit OR sphere rotation OR light orbit (at least one)
* Terminal redraw per frame (clear screen + print frame)
* FPS cap

**CLI**

* `--demo` : run the animated scene
* `--width`, `--height`
* `--fps`
* `--palette " .:-=+*#%@"`
* `--reflections 1`
* `--output out.txt` for still frame mode (if `--still`)

---

### 7) Non-Functional Requirements

* **Simplicity:** ~500–1200 lines total, clean separation of concerns.
* **Performance:** must run interactively on a laptop in terminal.

  * Use **NumPy** for vector math if using Python.
* **Portability:** macOS + Linux terminals (Windows optional).
* **Deterministic:** same inputs produce same output.

---

### 8) Tech Stack

**Recommended (simple + fast enough):**

* Python 3.11+
* NumPy
* Terminal rendering: basic ANSI escape codes (no heavy dependencies)

**Optional extras (stretch):**

* `rich` for nicer terminal rendering (not required)
* Export frames -> GIF via `imageio` (but keep core terminal-first)

---

### 9) System Design

**Modules**

1. `math3d.py`

   * Vec3 operations, normalization, dot, reflect, clamp
2. `objects.py`

   * `Sphere`, `Plane`
   * `intersect(ray)` returning hit distance + normal + material
3. `materials.py`

   * `DiffuseMaterial(color, shininess)`
   * `MirrorMaterial(reflectivity)`
4. `scene.py`

   * list of objects, lights, background
5. `raytracer.py`

   * `trace(ray, depth)` → color
   * shading + shadows + reflections
6. `ascii.py`

   * luminance + palette mapping
7. `main.py`

   * CLI, animation loop, printing

**Data structures**

* `Ray(origin: Vec3, direction: Vec3)`
* `Hit(t, point, normal, material)`
* `Light(position, intensity)`

---

### 10) Core Algorithm (Raytracing)

**Per frame**

1. Update time `t`
2. Update camera/light positions
3. For each pixel (x, y):

   * compute ray direction through camera plane
   * `color = trace(ray, depth=reflections)`
   * `lum = luminance(color)` (or grayscale only to keep it simple)
   * char = palette[lum]
4. Print frame

**Shading (simple but good-looking)**

* Ambient: `A`
* Diffuse: `max(dot(n, l), 0)`
* Specular (Blinn): `max(dot(n, h), 0)^shininess`
* Shadow: if blocked, reduce diffuse/specular
* Reflection: if mirror, add `reflectivity * trace(reflected_ray, depth-1)`

**Gamma**

* Apply `lum = lum^(1/2.2)` before palette mapping (optional but often improves look).

---

### 11) Scene Specification (Demo)

**Camera**

* Position: orbit around center at radius ~3
* LookAt: (0, 0.5, 0)
* FOV: ~60°

**Objects**

* Plane y=0 with checkerboard:

  * color = (1,1,1) or (0.1,0.1,0.1) based on floor tile
* Sphere mirror at (0, 0.8, 0)
* Sphere diffuse at (-1.2, 0.5, 1.0)

**Light**

* position: `(2*cos(t), 2.5, 2*sin(t))`
* intensity: 1.2

**Background**

* simple gradient or dark

---

### 12) UX / Output Design

**Terminal**

* Clear screen using ANSI (`\x1b[2J\x1b[H`)
* Hide cursor while animating, show on exit
* Frame string built as lines joined with `\n`

**Palette presets**

* `classic`: `" .:-=+*#%@"`
* `dense`: `" .'`^",:;Il!i><~+_-?][}{1)(|\/*tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$"`
* `blocks`: `" ░▒▓█"` (super readable)

---

### 13) Milestones (Build Plan)

**M1 — Still image (1 scene, no reflections)**

* Vec3 + Ray + Sphere + Plane + camera rays
* Ambient+diffuse shading
* ASCII mapping
* Output a single frame

**M2 — Animation**

* Frame loop + camera orbit or light orbit
* FPS cap + clean redraw

**M3 — Shadows**

* Shadow rays
* Make it instantly “3D”

**M4 — Reflections (the “waw”)**

* Mirror sphere, 1 bounce
* Tune shininess/specular

**M5 — Polish**

* Palettes, resolution presets, gamma, graceful exit

---

### 14) Acceptance Criteria

* `python main.py --demo` runs and shows:

  * a visible sphere with shading
  * moving highlight (specular)
  * checkerboard floor perspective
  * shadows under at least one object
  * mirror sphere reflecting something (floor pattern / other sphere)
* Runs at interactive speed at 120×60 in a standard terminal (or a documented recommended size).
* Code is readable: modules separated, no giant single file (except if you deliberately choose “single-file art mode” as a variant).

---

### 15) Testing Plan

* Unit tests for:

  * `dot`, `normalize`, `reflect`
  * sphere intersection correctness (known rays)
  * plane intersection correctness
* Visual tests:

  * fixed seed / fixed camera frame dump to `.txt` and compare hash (basic regression)

---

### 16) Stretch Goals (Optional but very “tweetable”)

1. **Soft shadows** (cheap hack): sample the light position 4–16 times in a tiny disk.
2. **Depth-of-field**: jitter rays from aperture (small sample count).
3. **Fog**: distance-based attenuation = cinematic depth.
4. **Mouse/keyboard control**: WASD camera in terminal.
5. **Export GIF**: render N frames to images then encode.

---

### 17) Repo Structure

```
terminalray/
  main.py
  raytracer.py
  scene.py
  objects.py
  materials.py
  math3d.py
  ascii.py
  tests/
    test_intersections.py
    test_math3d.py
  README.md
```

---

If you want, I can also give you:

* a **minimal file-by-file scaffold** (ready to paste)
* and a **“waw-first” implementation order** where you get something cool on screen in <100 lines, then refactor into modules.
